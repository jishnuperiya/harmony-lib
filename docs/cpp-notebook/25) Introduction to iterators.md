
## 1. What is an iterator?
**iterator defention**
	a lightweright object that gives you controlled access to the internals of a container without exposing its structure

-> **this allows generic algorithms to operate on any container**

example:
```cpp
for (auto it=v.begin(); it != v.end(), ++it)
{
	std::cout << *it;
}
```

what is happening here:
- `it` know how to move
- `*it` know how to access the element
- `begin()` gives the first pos
- `end()` marks the stopping point. (not a valid element)

## 2 Why iterators exist? 

iterators were created to:

**Seperate data storage from alogirhtms**

this is why STL is so powerful

## 3. Iterator operations (the "interface")

Iteraotrs must normally support:

### `*it` — dereference

Gives access to the element.

### `++it` — increment

Move to the next element.

### `--it` (if bidirectional)

Move backward.

### comparison

`it == other`  
`it != other`

### copyability

Iterators must be cheap to copy.



## 4. Categories of iterators

**5 primary categories**

input ouput bidrection random access, and foirward

since the note_Set is backed by std::set lets look only at **bidirectional iterator**

Supports:

- `++it`
    
- `--it`
    
- `*it`
    
- `==` / `!=`
    
- multi-pass traversal
    

Cannot:

- jump (like `it + 5`)
    
- do random indexing

## 5. What does dereferencing an iterator give you?
very important:
**it give you access to eht element the iterator currently points to**

`*it` give :
-  a reference to the element stored in the container
- specifically, a `T&` (for non-const iterator)
- or `const T&` (for const iterator)

quiz: what about iterator of a map ? 
ans: it gives you:
``const std::pair<const K, V>&`


#### Dereferencing an iterator gives you the **lvalue reference to the stored object**.

for mutable iterators:

```cpp
T& operator*() const;
```

for const iterators:

```cpp
const T& operator*() const;
```

-> iterator nevery copy the memory. just returns a reference to the actual element inside the container
	 this is why modifiying through an iterator modifies the container

you can modify the element though iterator only if:
- iterator is not const
- underlying container allows modification of the element (eg: std::set doesnt allow)

### Special Case: `std::set` and `std::map` iterators

elements in std::set are const once stored.

so dereferencing gives:

```cpp
const T& operator*() const;
```

you cannot modify the element.

## 3 minimum opeators any iterators needs

reference operator*() const;
iterator& operator++()  - pre increment
operator==

operator!= is autogenerated if you provide ==

## iterator invalidation

iterator is like apointer to a container

if the container change or move the element the itreator pointed to, the iterator becomes invalid - dereferencing it becomes UB


|Container|Do elements move on insert/erase?|Result|
|---|---|---|
|**vector**|Yes (shifts, reallocations)|Iterators invalidated|
|**string**|Yes|Same as vector|
|**deque**|Sometimes|Mid-insert invalidates|
|**list**|No|Iterators stable|
|**set/map**|No|Iterators stable|
|**unordered***|Rehash moves everything|All invalidated|


node based containers -> no invalidation for iterators.

because the existing nodes in heap doesnt get affected when you add or erase nodes


does it mean containres which have contiguous block of memory -> means iterator get invalidated when new members added or deleted?

not necessarily.

only when the memory block changes upon adding or deleting items

in case of vector, sometime reallcoation happens.

becuase when you push back, its not sure that the next memory location is free for vector to use. so sometime vectcor has to allcoate new memory location and delete the old one. in this case the iteraotr get invalidated


**cases when iterator in vector get invalidated**

### CASE 1: push_back()

MAY invalidate **all** iterators  
(because entire block may move due to reallocation)

### CASE 2: erase(i)

INVALIDATES iterators **from i to end**  
(because those elements get moved)

###  CASE 3: insert(i)

Same logic — shifting to right → invalidates **from i to end**



**what happens when i use bitset for notes?**

bit:      0 1 2 3 4 5 6 7 8 9 10 11
value:    1 0 1 1 0 0 0 1 0 0  1  0


here position of each bit is fixed forever

so iterator invalidation is not needed

so for bitset:  Invalidate the iterator **only if the specific element being erased is the one the iterator currently points to.**


## Reverse iterator

lets you walk the container in reverse

`std::vector<int> v = {10, 20, 30};`

```
index:   0    1    2
value:  [10] [20] [30]

```

```

rit.base() = end()

10   20   30   [end]
               ↑
         rit.base()


*rit is the element before end → 30

```

also when you do ++, the iterator move backwards



## what make iterator cheap

cheap iteraor behaves likea pointer

its small, trivial and fast to copy

no heap

ideal iteraotr size:
- 8 bytes (pointer to the container) 
- 8 bytes (index - to  know the current poisition of iterator inside the container) - int

iterator size will be 16 bytes in a 64 bit system


even if you try to make the index 1 byte using uint8_t, the compiler will padd it and make 8 + 1 +7 = 16 bytes

not worth it



## const vs non const iterator

iteraotr: lets you modify the element it refers to
const iterator: lets you only read the element it referes to

- vector - elelments are mutable:
so you can provide a const iterator(for using on const vector ojbects) and non const iterator 
- set - elements are immutable:
so `t*` returns const element.

in the bitset<12> note set,

### Let's compare a real mutable iterator vs your iterator

## ✔ Mutable iterator (vector)


```
std::vector<int> v = {10,20,30}; 
auto it = v.begin(); 
*it = 99;  // modifies v[0]

```

Here:

- `it` returns `int&`
    
- There is a real element object that can be changed
    
- This is **conceptual mutability**
    



## ❌ Your iterator

```
`auto it = ns.begin(); 
int x = *it;    // x = 0 or 2 or whatever
*it = 5;        // ❌ does not compile, no reference returned`
```


Because:

- there is no object behind the iterator
    
- your elements are just bits
    
- dereference gives a **value**, not a reference
    
- you cannot assign to `*it`
    

This is **conceptual immutability**, exactly like `std::set<int>::iterator`



### ✔ **Conceptually mutable element**

→ means `*it = something` modifies the container  
→ only possible when `operator*` returns `T&`

### ❌ **Conceptually immutable element**

→ means `*it` returns value or const reference  
→ container cannot be modified through iterator dereferencing

### In YOUR container:

- You can modify the container (bits) using `insert()` or `erase()`.
    
- You **cannot modify the container through the iterator dereference.**
    

### Therefore:

- Your iterator returns a value → **immutable**
    
- Your container allows modification → **via container methods**, not via iterator
    

This is exactly like:

- `std::set`: can erase/insert, but cannot change element via `*it`
    
- `std::map`: same
    
- Your `note_set`: same


